import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// node_modules/choo/node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "node_modules/choo/node_modules/nanoassert/index.js"(exports, module) {
    assert.notEqual = notEqual;
    assert.notOk = notOk;
    assert.equal = equal;
    assert.ok = assert;
    module.exports = assert;
    function equal(a, b, m) {
      assert(a == b, m);
    }
    function notEqual(a, b, m) {
      assert(a != b, m);
    }
    function notOk(t, m) {
      assert(!t, m);
    }
    function assert(t, m) {
      if (!t)
        throw new Error(m || "AssertionError");
    }
  }
});

// node_modules/choo/node_modules/nanoscheduler/index.js
var require_nanoscheduler = __commonJS({
  "node_modules/choo/node_modules/nanoscheduler/index.js"(exports, module) {
    var assert = require_nanoassert();
    var hasWindow = typeof window !== "undefined";
    function createScheduler() {
      var scheduler;
      if (hasWindow) {
        if (!window._nanoScheduler)
          window._nanoScheduler = new NanoScheduler(true);
        scheduler = window._nanoScheduler;
      } else {
        scheduler = new NanoScheduler();
      }
      return scheduler;
    }
    function NanoScheduler(hasWindow2) {
      this.hasWindow = hasWindow2;
      this.hasIdle = this.hasWindow && window.requestIdleCallback;
      this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout;
      this.scheduled = false;
      this.queue = [];
    }
    NanoScheduler.prototype.push = function(cb) {
      assert.equal(typeof cb, "function", "nanoscheduler.push: cb should be type function");
      this.queue.push(cb);
      this.schedule();
    };
    NanoScheduler.prototype.schedule = function() {
      if (this.scheduled)
        return;
      this.scheduled = true;
      var self = this;
      this.method(function(idleDeadline) {
        var cb;
        while (self.queue.length && idleDeadline.timeRemaining() > 0) {
          cb = self.queue.shift();
          cb(idleDeadline);
        }
        self.scheduled = false;
        if (self.queue.length)
          self.schedule();
      });
    };
    NanoScheduler.prototype.setTimeout = function(cb) {
      setTimeout(cb, 0, {
        timeRemaining: function() {
          return 1;
        }
      });
    };
    module.exports = createScheduler;
  }
});

// node_modules/choo/node_modules/nanotiming/browser.js
var require_browser = __commonJS({
  "node_modules/choo/node_modules/nanotiming/browser.js"(exports, module) {
    var scheduler = require_nanoscheduler()();
    var assert = require_nanoassert();
    var perf;
    nanotiming.disabled = true;
    try {
      perf = window.performance;
      nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === "true" || !perf.mark;
    } catch (e) {
    }
    module.exports = nanotiming;
    function nanotiming(name) {
      assert.equal(typeof name, "string", "nanotiming: name should be type string");
      if (nanotiming.disabled)
        return noop;
      var uuid = (perf.now() * 1e4).toFixed() % Number.MAX_SAFE_INTEGER;
      var startName = "start-" + uuid + "-" + name;
      perf.mark(startName);
      function end(cb) {
        var endName = "end-" + uuid + "-" + name;
        perf.mark(endName);
        scheduler.push(function() {
          var err = null;
          try {
            var measureName = name + " [" + uuid + "]";
            perf.measure(measureName, startName, endName);
            perf.clearMarks(startName);
            perf.clearMarks(endName);
          } catch (e) {
            err = e;
          }
          if (cb)
            cb(err, name);
        });
      }
      end.uuid = uuid;
      return end;
    }
    function noop(cb) {
      if (cb) {
        scheduler.push(function() {
          cb(new Error("nanotiming: performance API unavailable"));
        });
      }
    }
  }
});

// node_modules/choo/node_modules/nanomorph/lib/events.js
var require_events = __commonJS({
  "node_modules/choo/node_modules/nanomorph/lib/events.js"(exports, module) {
    module.exports = [
      // attribute events (can be set with attributes)
      "onclick",
      "ondblclick",
      "onmousedown",
      "onmouseup",
      "onmouseover",
      "onmousemove",
      "onmouseout",
      "onmouseenter",
      "onmouseleave",
      "ontouchcancel",
      "ontouchend",
      "ontouchmove",
      "ontouchstart",
      "ondragstart",
      "ondrag",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondrop",
      "ondragend",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onunload",
      "onabort",
      "onerror",
      "onresize",
      "onscroll",
      "onselect",
      "onchange",
      "onsubmit",
      "onreset",
      "onfocus",
      "onblur",
      "oninput",
      "onanimationend",
      "onanimationiteration",
      "onanimationstart",
      // other common events
      "oncontextmenu",
      "onfocusin",
      "onfocusout"
    ];
  }
});

// node_modules/choo/node_modules/nanomorph/lib/morph.js
var require_morph = __commonJS({
  "node_modules/choo/node_modules/nanomorph/lib/morph.js"(exports, module) {
    var events = require_events();
    var eventsLength = events.length;
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    module.exports = morph;
    function morph(newNode, oldNode) {
      var nodeType = newNode.nodeType;
      var nodeName = newNode.nodeName;
      if (nodeType === ELEMENT_NODE) {
        copyAttrs(newNode, oldNode);
      }
      if (nodeType === TEXT_NODE || nodeType === COMMENT_NODE) {
        if (oldNode.nodeValue !== newNode.nodeValue) {
          oldNode.nodeValue = newNode.nodeValue;
        }
      }
      if (nodeName === "INPUT")
        updateInput(newNode, oldNode);
      else if (nodeName === "OPTION")
        updateOption(newNode, oldNode);
      else if (nodeName === "TEXTAREA")
        updateTextarea(newNode, oldNode);
      copyEvents(newNode, oldNode);
    }
    function copyAttrs(newNode, oldNode) {
      var oldAttrs = oldNode.attributes;
      var newAttrs = newNode.attributes;
      var attrNamespaceURI = null;
      var attrValue = null;
      var fromValue = null;
      var attrName = null;
      var attr = null;
      for (var i = newAttrs.length - 1; i >= 0; --i) {
        attr = newAttrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;
        if (attrNamespaceURI) {
          attrName = attr.localName || attrName;
          fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName);
          if (fromValue !== attrValue) {
            oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
          }
        } else {
          if (!oldNode.hasAttribute(attrName)) {
            oldNode.setAttribute(attrName, attrValue);
          } else {
            fromValue = oldNode.getAttribute(attrName);
            if (fromValue !== attrValue) {
              if (attrValue === "null" || attrValue === "undefined") {
                oldNode.removeAttribute(attrName);
              } else {
                oldNode.setAttribute(attrName, attrValue);
              }
            }
          }
        }
      }
      for (var j = oldAttrs.length - 1; j >= 0; --j) {
        attr = oldAttrs[j];
        if (attr.specified !== false) {
          attrName = attr.name;
          attrNamespaceURI = attr.namespaceURI;
          if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
              oldNode.removeAttributeNS(attrNamespaceURI, attrName);
            }
          } else {
            if (!newNode.hasAttributeNS(null, attrName)) {
              oldNode.removeAttribute(attrName);
            }
          }
        }
      }
    }
    function copyEvents(newNode, oldNode) {
      for (var i = 0; i < eventsLength; i++) {
        var ev = events[i];
        if (newNode[ev]) {
          oldNode[ev] = newNode[ev];
        } else if (oldNode[ev]) {
          oldNode[ev] = void 0;
        }
      }
    }
    function updateOption(newNode, oldNode) {
      updateAttribute(newNode, oldNode, "selected");
    }
    function updateInput(newNode, oldNode) {
      var newValue = newNode.value;
      var oldValue = oldNode.value;
      updateAttribute(newNode, oldNode, "checked");
      updateAttribute(newNode, oldNode, "disabled");
      if (newNode.indeterminate !== oldNode.indeterminate) {
        oldNode.indeterminate = newNode.indeterminate;
      }
      if (oldNode.type === "file")
        return;
      if (newValue !== oldValue) {
        oldNode.setAttribute("value", newValue);
        oldNode.value = newValue;
      }
      if (newValue === "null") {
        oldNode.value = "";
        oldNode.removeAttribute("value");
      }
      if (!newNode.hasAttributeNS(null, "value")) {
        oldNode.removeAttribute("value");
      } else if (oldNode.type === "range") {
        oldNode.value = newValue;
      }
    }
    function updateTextarea(newNode, oldNode) {
      var newValue = newNode.value;
      if (newValue !== oldNode.value) {
        oldNode.value = newValue;
      }
      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {
        if (newValue === "" && oldNode.firstChild.nodeValue === oldNode.placeholder) {
          return;
        }
        oldNode.firstChild.nodeValue = newValue;
      }
    }
    function updateAttribute(newNode, oldNode, name) {
      if (newNode[name] !== oldNode[name]) {
        oldNode[name] = newNode[name];
        if (newNode[name]) {
          oldNode.setAttribute(name, "");
        } else {
          oldNode.removeAttribute(name);
        }
      }
    }
  }
});

// node_modules/choo/node_modules/nanomorph/index.js
var require_nanomorph = __commonJS({
  "node_modules/choo/node_modules/nanomorph/index.js"(exports, module) {
    var assert = require_nanoassert();
    var morph = require_morph();
    var TEXT_NODE = 3;
    module.exports = nanomorph;
    function nanomorph(oldTree, newTree, options) {
      assert.equal(typeof oldTree, "object", "nanomorph: oldTree should be an object");
      assert.equal(typeof newTree, "object", "nanomorph: newTree should be an object");
      if (options && options.childrenOnly) {
        updateChildren(newTree, oldTree);
        return oldTree;
      }
      assert.notEqual(
        newTree.nodeType,
        11,
        "nanomorph: newTree should have one root node (which is not a DocumentFragment)"
      );
      return walk(newTree, oldTree);
    }
    function walk(newNode, oldNode) {
      if (!oldNode) {
        return newNode;
      } else if (!newNode) {
        return null;
      } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {
        return oldNode;
      } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {
        return newNode;
      } else {
        morph(newNode, oldNode);
        updateChildren(newNode, oldNode);
        return oldNode;
      }
    }
    function getComponentId(node) {
      return node.dataset ? node.dataset.nanomorphComponentId : void 0;
    }
    function updateChildren(newNode, oldNode) {
      var oldChild, newChild, morphed, oldMatch;
      var offset = 0;
      for (var i = 0; ; i++) {
        oldChild = oldNode.childNodes[i];
        newChild = newNode.childNodes[i - offset];
        if (!oldChild && !newChild) {
          break;
        } else if (!newChild) {
          oldNode.removeChild(oldChild);
          i--;
        } else if (!oldChild) {
          oldNode.appendChild(newChild);
          offset++;
        } else if (same(newChild, oldChild)) {
          morphed = walk(newChild, oldChild);
          if (morphed !== oldChild) {
            oldNode.replaceChild(morphed, oldChild);
            offset++;
          }
        } else {
          oldMatch = null;
          for (var j = i; j < oldNode.childNodes.length; j++) {
            if (same(oldNode.childNodes[j], newChild)) {
              oldMatch = oldNode.childNodes[j];
              break;
            }
          }
          if (oldMatch) {
            morphed = walk(newChild, oldMatch);
            if (morphed !== oldMatch)
              offset++;
            oldNode.insertBefore(morphed, oldChild);
          } else if (!newChild.id && !oldChild.id) {
            morphed = walk(newChild, oldChild);
            if (morphed !== oldChild) {
              oldNode.replaceChild(morphed, oldChild);
              offset++;
            }
          } else {
            oldNode.insertBefore(newChild, oldChild);
            offset++;
          }
        }
      }
    }
    function same(a, b) {
      if (a.id)
        return a.id === b.id;
      if (a.isSameNode)
        return a.isSameNode(b);
      if (a.tagName !== b.tagName)
        return false;
      if (a.type === TEXT_NODE)
        return a.nodeValue === b.nodeValue;
      return false;
    }
  }
});

export {
  require_nanoassert,
  require_browser,
  require_nanomorph
};
//# sourceMappingURL=chunk-4XJRYKTF.js.map
