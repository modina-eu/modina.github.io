import {
  require_browser,
  require_nanomorph
} from "./chunk-4XJRYKTF.js";
import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// browser-external:min-document
var require_min_document = __commonJS({
  "browser-external:min-document"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "min-document" has been externalized for browser compatibility. Cannot access "min-document.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/choo/node_modules/global/document.js
var require_document = __commonJS({
  "node_modules/choo/node_modules/global/document.js"(exports, module) {
    var topLevel = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
    var minDoc = require_min_document();
    var doccy;
    if (typeof document !== "undefined") {
      doccy = document;
    } else {
      doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
      if (!doccy) {
        doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
      }
    }
    module.exports = doccy;
  }
});

// node_modules/choo/node_modules/global/window.js
var require_window = __commonJS({
  "node_modules/choo/node_modules/global/window.js"(exports, module) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// node_modules/choo/node_modules/on-load/index.js
var require_on_load = __commonJS({
  "node_modules/choo/node_modules/on-load/index.js"(exports, module) {
    var document2 = require_document();
    var window2 = require_window();
    var watch = /* @__PURE__ */ Object.create(null);
    var KEY_ID = "onloadid" + Math.random().toString(36).slice(2);
    var KEY_ATTR = "data-" + KEY_ID;
    var INDEX = 0;
    if (window2 && window2.MutationObserver) {
      observer = new MutationObserver(function(mutations) {
        if (Object.keys(watch).length < 1)
          return;
        for (var i = 0; i < mutations.length; i++) {
          if (mutations[i].attributeName === KEY_ATTR) {
            eachAttr(mutations[i], turnon, turnoff);
            continue;
          }
          eachMutation(mutations[i].removedNodes, function(index, el) {
            if (!document2.documentElement.contains(el))
              turnoff(index, el);
          });
          eachMutation(mutations[i].addedNodes, function(index, el) {
            if (document2.documentElement.contains(el))
              turnon(index, el);
          });
        }
      });
      observer.observe(document2.documentElement, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeOldValue: true,
        attributeFilter: [KEY_ATTR]
      });
    }
    var observer;
    module.exports = function onload(el, on, off, caller) {
      on = on || function() {
      };
      off = off || function() {
      };
      el.setAttribute(KEY_ATTR, "o" + INDEX);
      watch["o" + INDEX] = [on, off, 0, caller || onload.caller];
      INDEX += 1;
      return el;
    };
    module.exports.KEY_ATTR = KEY_ATTR;
    module.exports.KEY_ID = KEY_ID;
    function turnon(index, el) {
      if (watch[index][0] && watch[index][2] === 0) {
        watch[index][0](el);
        watch[index][2] = 1;
      }
    }
    function turnoff(index, el) {
      if (watch[index][1] && watch[index][2] === 1) {
        watch[index][1](el);
        watch[index][2] = 0;
      }
    }
    function eachAttr(mutation, on, off) {
      var newValue = mutation.target.getAttribute(KEY_ATTR);
      if (sameOrigin(mutation.oldValue, newValue)) {
        watch[newValue] = watch[mutation.oldValue];
        return;
      }
      if (watch[mutation.oldValue]) {
        off(mutation.oldValue, mutation.target);
      }
      if (watch[newValue]) {
        on(newValue, mutation.target);
      }
    }
    function sameOrigin(oldValue, newValue) {
      if (!oldValue || !newValue)
        return false;
      return watch[oldValue][3] === watch[newValue][3];
    }
    function eachMutation(nodes, fn) {
      var keys = Object.keys(watch);
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i] && nodes[i].getAttribute && nodes[i].getAttribute(KEY_ATTR)) {
          var onloadid = nodes[i].getAttribute(KEY_ATTR);
          keys.forEach(function(k) {
            if (onloadid === k) {
              fn(k, nodes[i]);
            }
          });
        }
        if (nodes[i] && nodes[i].childNodes.length > 0) {
          eachMutation(nodes[i].childNodes, fn);
        }
      }
    }
  }
});

// node_modules/choo/node_modules/nanocomponent/node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "node_modules/choo/node_modules/nanocomponent/node_modules/nanoassert/index.js"(exports, module) {
    module.exports = assert;
    var AssertionError = class extends Error {
    };
    AssertionError.prototype.name = "AssertionError";
    function assert(t, m) {
      if (!t) {
        var err = new AssertionError(m);
        if (Error.captureStackTrace)
          Error.captureStackTrace(err, assert);
        throw err;
      }
    }
  }
});

// node_modules/choo/node_modules/nanocomponent/index.js
var require_nanocomponent = __commonJS({
  "node_modules/choo/node_modules/nanocomponent/index.js"(exports, module) {
    var document2 = require_document();
    var nanotiming = require_browser();
    var morph = require_nanomorph();
    var onload = require_on_load();
    var assert = require_nanoassert();
    var OL_KEY_ID = onload.KEY_ID;
    var OL_ATTR_ID = onload.KEY_ATTR;
    module.exports = Nanocomponent;
    function makeID() {
      return "ncid-" + Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    Nanocomponent.makeID = makeID;
    function Nanocomponent(name) {
      this._hasWindow = typeof window !== "undefined";
      this._id = null;
      this._ncID = null;
      this._olID = null;
      this._proxy = null;
      this._loaded = false;
      this._rootNodeName = null;
      this._name = name || "nanocomponent";
      this._rerender = false;
      this._handleLoad = this._handleLoad.bind(this);
      this._handleUnload = this._handleUnload.bind(this);
      this._arguments = [];
      const self2 = this;
      Object.defineProperty(this, "element", {
        get: function() {
          const el = document2.getElementById(self2._id);
          if (el)
            return el.dataset.nanocomponent === self2._ncID ? el : void 0;
        }
      });
    }
    Nanocomponent.prototype.render = function() {
      const renderTiming = nanotiming(this._name + ".render");
      const self2 = this;
      const args = new Array(arguments.length);
      let el;
      for (let i = 0; i < arguments.length; i++)
        args[i] = arguments[i];
      if (!this._hasWindow) {
        const createTiming = nanotiming(this._name + ".create");
        el = this.createElement.apply(this, args);
        createTiming();
        renderTiming();
        return el;
      } else if (this.element) {
        el = this.element;
        const updateTiming = nanotiming(this._name + ".update");
        const shouldUpdate = this._rerender || this.update.apply(this, args);
        updateTiming();
        if (this._rerender)
          this._rerender = false;
        if (shouldUpdate) {
          const desiredHtml = this._handleRender(args);
          const morphTiming = nanotiming(this._name + ".morph");
          morph(el, desiredHtml);
          morphTiming();
          if (this.afterupdate)
            this.afterupdate(el);
        }
        if (!this._proxy) {
          this._proxy = this._createProxy();
        }
        renderTiming();
        return this._proxy;
      } else {
        this._reset();
        el = this._handleRender(args);
        if (this.beforerender)
          this.beforerender(el);
        if (this.load || this.unload || this.afterreorder) {
          onload(el, self2._handleLoad, self2._handleUnload, self2._ncID);
          this._olID = el.dataset[OL_KEY_ID];
        }
        renderTiming();
        return el;
      }
    };
    Nanocomponent.prototype.rerender = function() {
      assert(this.element, "nanocomponent: cant rerender on an unmounted dom node");
      this._rerender = true;
      this.render.apply(this, this._arguments);
    };
    Nanocomponent.prototype._handleRender = function(args) {
      const createElementTiming = nanotiming(this._name + ".createElement");
      const el = this.createElement.apply(this, args);
      createElementTiming();
      if (!this._rootNodeName)
        this._rootNodeName = el.nodeName;
      assert(el instanceof window.Element, "nanocomponent: createElement should return a single DOM node");
      assert(this._rootNodeName === el.nodeName, "nanocomponent: root node types cannot differ between re-renders");
      this._arguments = args;
      return this._brandNode(this._ensureID(el));
    };
    Nanocomponent.prototype._createProxy = function() {
      const proxy = document2.createElement(this._rootNodeName);
      const self2 = this;
      this._brandNode(proxy);
      proxy.id = this._id;
      proxy.setAttribute("data-proxy", "");
      proxy.isSameNode = function(el) {
        return el && el.dataset.nanocomponent === self2._ncID;
      };
      return proxy;
    };
    Nanocomponent.prototype._reset = function() {
      this._ncID = Nanocomponent.makeID();
      this._olID = null;
      this._id = null;
      this._proxy = null;
      this._rootNodeName = null;
    };
    Nanocomponent.prototype._brandNode = function(node) {
      node.setAttribute("data-nanocomponent", this._ncID);
      if (this._olID)
        node.setAttribute(OL_ATTR_ID, this._olID);
      return node;
    };
    Nanocomponent.prototype._ensureID = function(node) {
      if (node.id)
        this._id = node.id;
      else
        node.id = this._id = this._ncID;
      if (this._proxy && this._proxy.id !== this._id)
        this._proxy.id = this._id;
      return node;
    };
    Nanocomponent.prototype._handleLoad = function(el) {
      if (this._loaded) {
        if (this.afterreorder)
          this.afterreorder(el);
        return;
      }
      this._loaded = true;
      if (this.load)
        this.load(el);
    };
    Nanocomponent.prototype._handleUnload = function(el) {
      if (this.element)
        return;
      this._loaded = false;
      if (this.unload)
        this.unload(el);
    };
    Nanocomponent.prototype.createElement = function() {
      throw new Error("nanocomponent: createElement should be implemented!");
    };
    Nanocomponent.prototype.update = function() {
      throw new Error("nanocomponent: update should be implemented!");
    };
  }
});

// node_modules/choo/component/index.js
var require_component = __commonJS({
  "node_modules/choo/component/index.js"(exports, module) {
    module.exports = require_nanocomponent();
  }
});
export default require_component();
//# sourceMappingURL=choo_component.js.map
