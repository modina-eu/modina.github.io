{
  "version": 3,
  "sources": ["../../choo/node_modules/nanoassert/index.js", "../../choo/node_modules/nanoscheduler/index.js", "../../choo/node_modules/nanotiming/browser.js", "../../choo/node_modules/nanomorph/lib/events.js", "../../choo/node_modules/nanomorph/lib/morph.js", "../../choo/node_modules/nanomorph/index.js"],
  "sourcesContent": ["assert.notEqual = notEqual\nassert.notOk = notOk\nassert.equal = equal\nassert.ok = assert\n\nmodule.exports = assert\n\nfunction equal (a, b, m) {\n  assert(a == b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notEqual (a, b, m) {\n  assert(a != b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notOk (t, m) {\n  assert(!t, m)\n}\n\nfunction assert (t, m) {\n  if (!t) throw new Error(m || 'AssertionError')\n}\n", "var assert = require('assert')\n\nvar hasWindow = typeof window !== 'undefined'\n\nfunction createScheduler () {\n  var scheduler\n  if (hasWindow) {\n    if (!window._nanoScheduler) window._nanoScheduler = new NanoScheduler(true)\n    scheduler = window._nanoScheduler\n  } else {\n    scheduler = new NanoScheduler()\n  }\n  return scheduler\n}\n\nfunction NanoScheduler (hasWindow) {\n  this.hasWindow = hasWindow\n  this.hasIdle = this.hasWindow && window.requestIdleCallback\n  this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout\n  this.scheduled = false\n  this.queue = []\n}\n\nNanoScheduler.prototype.push = function (cb) {\n  assert.equal(typeof cb, 'function', 'nanoscheduler.push: cb should be type function')\n\n  this.queue.push(cb)\n  this.schedule()\n}\n\nNanoScheduler.prototype.schedule = function () {\n  if (this.scheduled) return\n\n  this.scheduled = true\n  var self = this\n  this.method(function (idleDeadline) {\n    var cb\n    while (self.queue.length && idleDeadline.timeRemaining() > 0) {\n      cb = self.queue.shift()\n      cb(idleDeadline)\n    }\n    self.scheduled = false\n    if (self.queue.length) self.schedule()\n  })\n}\n\nNanoScheduler.prototype.setTimeout = function (cb) {\n  setTimeout(cb, 0, {\n    timeRemaining: function () {\n      return 1\n    }\n  })\n}\n\nmodule.exports = createScheduler\n", "var scheduler = require('nanoscheduler')()\nvar assert = require('assert')\n\nvar perf\nnanotiming.disabled = true\ntry {\n  perf = window.performance\n  nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === 'true' || !perf.mark\n} catch (e) { }\n\nmodule.exports = nanotiming\n\nfunction nanotiming (name) {\n  assert.equal(typeof name, 'string', 'nanotiming: name should be type string')\n\n  if (nanotiming.disabled) return noop\n\n  var uuid = (perf.now() * 10000).toFixed() % Number.MAX_SAFE_INTEGER\n  var startName = 'start-' + uuid + '-' + name\n  perf.mark(startName)\n\n  function end (cb) {\n    var endName = 'end-' + uuid + '-' + name\n    perf.mark(endName)\n\n    scheduler.push(function () {\n      var err = null\n      try {\n        var measureName = name + ' [' + uuid + ']'\n        perf.measure(measureName, startName, endName)\n        perf.clearMarks(startName)\n        perf.clearMarks(endName)\n      } catch (e) { err = e }\n      if (cb) cb(err, name)\n    })\n  }\n\n  end.uuid = uuid\n  return end\n}\n\nfunction noop (cb) {\n  if (cb) {\n    scheduler.push(function () {\n      cb(new Error('nanotiming: performance API unavailable'))\n    })\n  }\n}\n", "module.exports = [\n  // attribute events (can be set with attributes)\n  'onclick',\n  'ondblclick',\n  'onmousedown',\n  'onmouseup',\n  'onmouseover',\n  'onmousemove',\n  'onmouseout',\n  'onmouseenter',\n  'onmouseleave',\n  'ontouchcancel',\n  'ontouchend',\n  'ontouchmove',\n  'ontouchstart',\n  'ondragstart',\n  'ondrag',\n  'ondragenter',\n  'ondragleave',\n  'ondragover',\n  'ondrop',\n  'ondragend',\n  'onkeydown',\n  'onkeypress',\n  'onkeyup',\n  'onunload',\n  'onabort',\n  'onerror',\n  'onresize',\n  'onscroll',\n  'onselect',\n  'onchange',\n  'onsubmit',\n  'onreset',\n  'onfocus',\n  'onblur',\n  'oninput',\n  'onanimationend',\n  'onanimationiteration',\n  'onanimationstart',\n  // other common events\n  'oncontextmenu',\n  'onfocusin',\n  'onfocusout'\n]\n", "var events = require('./events')\nvar eventsLength = events.length\n\nvar ELEMENT_NODE = 1\nvar TEXT_NODE = 3\nvar COMMENT_NODE = 8\n\nmodule.exports = morph\n\n// diff elements and apply the resulting patch to the old node\n// (obj, obj) -> null\nfunction morph (newNode, oldNode) {\n  var nodeType = newNode.nodeType\n  var nodeName = newNode.nodeName\n\n  if (nodeType === ELEMENT_NODE) {\n    copyAttrs(newNode, oldNode)\n  }\n\n  if (nodeType === TEXT_NODE || nodeType === COMMENT_NODE) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') updateInput(newNode, oldNode)\n  else if (nodeName === 'OPTION') updateOption(newNode, oldNode)\n  else if (nodeName === 'TEXTAREA') updateTextarea(newNode, oldNode)\n\n  copyEvents(newNode, oldNode)\n}\n\nfunction copyAttrs (newNode, oldNode) {\n  var oldAttrs = oldNode.attributes\n  var newAttrs = newNode.attributes\n  var attrNamespaceURI = null\n  var attrValue = null\n  var fromValue = null\n  var attrName = null\n  var attr = null\n\n  for (var i = newAttrs.length - 1; i >= 0; --i) {\n    attr = newAttrs[i]\n    attrName = attr.name\n    attrNamespaceURI = attr.namespaceURI\n    attrValue = attr.value\n    if (attrNamespaceURI) {\n      attrName = attr.localName || attrName\n      fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName)\n      if (fromValue !== attrValue) {\n        oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue)\n      }\n    } else {\n      if (!oldNode.hasAttribute(attrName)) {\n        oldNode.setAttribute(attrName, attrValue)\n      } else {\n        fromValue = oldNode.getAttribute(attrName)\n        if (fromValue !== attrValue) {\n          // apparently values are always cast to strings, ah well\n          if (attrValue === 'null' || attrValue === 'undefined') {\n            oldNode.removeAttribute(attrName)\n          } else {\n            oldNode.setAttribute(attrName, attrValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (var j = oldAttrs.length - 1; j >= 0; --j) {\n    attr = oldAttrs[j]\n    if (attr.specified !== false) {\n      attrName = attr.name\n      attrNamespaceURI = attr.namespaceURI\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName\n        if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n          oldNode.removeAttributeNS(attrNamespaceURI, attrName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attrName)) {\n          oldNode.removeAttribute(attrName)\n        }\n      }\n    }\n  }\n}\n\nfunction copyEvents (newNode, oldNode) {\n  for (var i = 0; i < eventsLength; i++) {\n    var ev = events[i]\n    if (newNode[ev]) {           // if new element has a whitelisted attribute\n      oldNode[ev] = newNode[ev]  // update existing element\n    } else if (oldNode[ev]) {    // if existing element has it and new one doesnt\n      oldNode[ev] = undefined    // remove it from existing element\n    }\n  }\n}\n\nfunction updateOption (newNode, oldNode) {\n  updateAttribute(newNode, oldNode, 'selected')\n}\n\n// The \"value\" attribute is special for the <input> element since it sets the\n// initial value. Changing the \"value\" attribute without changing the \"value\"\n// property will have no effect since it is only used to the set the initial\n// value. Similar for the \"checked\" attribute, and \"disabled\".\nfunction updateInput (newNode, oldNode) {\n  var newValue = newNode.value\n  var oldValue = oldNode.value\n\n  updateAttribute(newNode, oldNode, 'checked')\n  updateAttribute(newNode, oldNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (newNode.indeterminate !== oldNode.indeterminate) {\n    oldNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can't be changed programatically\n  if (oldNode.type === 'file') return\n\n  if (newValue !== oldValue) {\n    oldNode.setAttribute('value', newValue)\n    oldNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    oldNode.value = ''\n    oldNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    oldNode.removeAttribute('value')\n  } else if (oldNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    oldNode.value = newValue\n  }\n}\n\nfunction updateTextarea (newNode, oldNode) {\n  var newValue = newNode.value\n  if (newValue !== oldNode.value) {\n    oldNode.value = newValue\n  }\n\n  if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n    // Needed for IE. Apparently IE sets the placeholder as the\n    // node value and vise versa. This ignores an empty update.\n    if (newValue === '' && oldNode.firstChild.nodeValue === oldNode.placeholder) {\n      return\n    }\n\n    oldNode.firstChild.nodeValue = newValue\n  }\n}\n\nfunction updateAttribute (newNode, oldNode, name) {\n  if (newNode[name] !== oldNode[name]) {\n    oldNode[name] = newNode[name]\n    if (newNode[name]) {\n      oldNode.setAttribute(name, '')\n    } else {\n      oldNode.removeAttribute(name)\n    }\n  }\n}\n", "var assert = require('nanoassert')\nvar morph = require('./lib/morph')\n\nvar TEXT_NODE = 3\n// var DEBUG = false\n\nmodule.exports = nanomorph\n\n// Morph one tree into another tree\n//\n// no parent\n//   -> same: diff and walk children\n//   -> not same: replace and return\n// old node doesn't exist\n//   -> insert new node\n// new node doesn't exist\n//   -> delete old node\n// nodes are not the same\n//   -> diff nodes and apply patch to old node\n// nodes are the same\n//   -> walk all child nodes and append to old node\nfunction nanomorph (oldTree, newTree, options) {\n  // if (DEBUG) {\n  //   console.log(\n  //   'nanomorph\\nold\\n  %s\\nnew\\n  %s',\n  //   oldTree && oldTree.outerHTML,\n  //   newTree && newTree.outerHTML\n  // )\n  // }\n  assert.equal(typeof oldTree, 'object', 'nanomorph: oldTree should be an object')\n  assert.equal(typeof newTree, 'object', 'nanomorph: newTree should be an object')\n\n  if (options && options.childrenOnly) {\n    updateChildren(newTree, oldTree)\n    return oldTree\n  }\n\n  assert.notEqual(\n    newTree.nodeType,\n    11,\n    'nanomorph: newTree should have one root node (which is not a DocumentFragment)'\n  )\n\n  return walk(newTree, oldTree)\n}\n\n// Walk and morph a dom tree\nfunction walk (newNode, oldNode) {\n  // if (DEBUG) {\n  //   console.log(\n  //   'walk\\nold\\n  %s\\nnew\\n  %s',\n  //   oldNode && oldNode.outerHTML,\n  //   newNode && newNode.outerHTML\n  // )\n  // }\n  if (!oldNode) {\n    return newNode\n  } else if (!newNode) {\n    return null\n  } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {\n    return oldNode\n  } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {\n    return newNode\n  } else {\n    morph(newNode, oldNode)\n    updateChildren(newNode, oldNode)\n    return oldNode\n  }\n}\n\nfunction getComponentId (node) {\n  return node.dataset ? node.dataset.nanomorphComponentId : undefined\n}\n\n// Update the children of elements\n// (obj, obj) -> null\nfunction updateChildren (newNode, oldNode) {\n  // if (DEBUG) {\n  //   console.log(\n  //   'updateChildren\\nold\\n  %s\\nnew\\n  %s',\n  //   oldNode && oldNode.outerHTML,\n  //   newNode && newNode.outerHTML\n  // )\n  // }\n  var oldChild, newChild, morphed, oldMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop\n  var offset = 0\n\n  for (var i = 0; ; i++) {\n    oldChild = oldNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n    // if (DEBUG) {\n    //   console.log(\n    //   '===\\n- old\\n  %s\\n- new\\n  %s',\n    //   oldChild && oldChild.outerHTML,\n    //   newChild && newChild.outerHTML\n    // )\n    // }\n    // Both nodes are empty, do nothing\n    if (!oldChild && !newChild) {\n      break\n\n    // There is no new child, remove old\n    } else if (!newChild) {\n      oldNode.removeChild(oldChild)\n      i--\n\n    // There is no old child, add new\n    } else if (!oldChild) {\n      oldNode.appendChild(newChild)\n      offset++\n\n    // Both nodes are the same, morph\n    } else if (same(newChild, oldChild)) {\n      morphed = walk(newChild, oldChild)\n      if (morphed !== oldChild) {\n        oldNode.replaceChild(morphed, oldChild)\n        offset++\n      }\n\n    // Both nodes do not share an ID or a placeholder, try reorder\n    } else {\n      oldMatch = null\n\n      // Try and find a similar node somewhere in the tree\n      for (var j = i; j < oldNode.childNodes.length; j++) {\n        if (same(oldNode.childNodes[j], newChild)) {\n          oldMatch = oldNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list\n      if (oldMatch) {\n        morphed = walk(newChild, oldMatch)\n        if (morphed !== oldMatch) offset++\n        oldNode.insertBefore(morphed, oldChild)\n\n      // It's safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !oldChild.id) {\n        morphed = walk(newChild, oldChild)\n        if (morphed !== oldChild) {\n          oldNode.replaceChild(morphed, oldChild)\n          offset++\n        }\n\n      // Insert the node at the index if we couldn't morph or find a matching node\n      } else {\n        oldNode.insertBefore(newChild, oldChild)\n        offset++\n      }\n    }\n  }\n}\n\nfunction same (a, b) {\n  if (a.id) return a.id === b.id\n  if (a.isSameNode) return a.isSameNode(b)\n  if (a.tagName !== b.tagName) return false\n  if (a.type === TEXT_NODE) return a.nodeValue === b.nodeValue\n  return false\n}\n"],
  "mappings": "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",
  "names": ["hasWindow"]
}
