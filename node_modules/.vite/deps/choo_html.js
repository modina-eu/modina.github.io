import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// node_modules/choo/node_modules/hyperscript-attribute-to-property/index.js
var require_hyperscript_attribute_to_property = __commonJS({
  "node_modules/choo/node_modules/hyperscript-attribute-to-property/index.js"(exports, module) {
    module.exports = attributeToProperty;
    var transform = {
      "class": "className",
      "for": "htmlFor",
      "http-equiv": "httpEquiv"
    };
    function attributeToProperty(h) {
      return function(tagName, attrs, children) {
        for (var attr in attrs) {
          if (attr in transform) {
            attrs[transform[attr]] = attrs[attr];
            delete attrs[attr];
          }
        }
        return h(tagName, attrs, children);
      };
    }
  }
});

// node_modules/choo/node_modules/hyperx/index.js
var require_hyperx = __commonJS({
  "node_modules/choo/node_modules/hyperx/index.js"(exports, module) {
    var attrToProp = require_hyperscript_attribute_to_property();
    var VAR = 0;
    var TEXT = 1;
    var OPEN = 2;
    var CLOSE = 3;
    var ATTR = 4;
    var ATTR_KEY = 5;
    var ATTR_KEY_W = 6;
    var ATTR_VALUE_W = 7;
    var ATTR_VALUE = 8;
    var ATTR_VALUE_SQ = 9;
    var ATTR_VALUE_DQ = 10;
    var ATTR_EQ = 11;
    var ATTR_BREAK = 12;
    var COMMENT = 13;
    module.exports = function(h, opts) {
      if (!opts)
        opts = {};
      var concat = opts.concat || function(a, b) {
        return String(a) + String(b);
      };
      if (opts.attrToProp !== false) {
        h = attrToProp(h);
      }
      return function(strings) {
        var state = TEXT, reg = "";
        var arglen = arguments.length;
        var parts = [];
        for (var i = 0; i < strings.length; i++) {
          if (i < arglen - 1) {
            var arg = arguments[i + 1];
            var p = parse(strings[i]);
            var xstate = state;
            if (xstate === ATTR_VALUE_DQ)
              xstate = ATTR_VALUE;
            if (xstate === ATTR_VALUE_SQ)
              xstate = ATTR_VALUE;
            if (xstate === ATTR_VALUE_W)
              xstate = ATTR_VALUE;
            if (xstate === ATTR)
              xstate = ATTR_KEY;
            if (xstate === OPEN) {
              if (reg === "/") {
                p.push([OPEN, "/", arg]);
                reg = "";
              } else {
                p.push([OPEN, arg]);
              }
            } else if (xstate === COMMENT && opts.comments) {
              reg += String(arg);
            } else if (xstate !== COMMENT) {
              p.push([VAR, xstate, arg]);
            }
            parts.push.apply(parts, p);
          } else
            parts.push.apply(parts, parse(strings[i]));
        }
        var tree = [null, {}, []];
        var stack = [[tree, -1]];
        for (var i = 0; i < parts.length; i++) {
          var cur = stack[stack.length - 1][0];
          var p = parts[i], s = p[0];
          if (s === OPEN && /^\//.test(p[1])) {
            var ix = stack[stack.length - 1][1];
            if (stack.length > 1) {
              stack.pop();
              stack[stack.length - 1][0][2][ix] = h(
                cur[0],
                cur[1],
                cur[2].length ? cur[2] : void 0
              );
            }
          } else if (s === OPEN) {
            var c = [p[1], {}, []];
            cur[2].push(c);
            stack.push([c, cur[2].length - 1]);
          } else if (s === ATTR_KEY || s === VAR && p[1] === ATTR_KEY) {
            var key = "";
            var copyKey;
            for (; i < parts.length; i++) {
              if (parts[i][0] === ATTR_KEY) {
                key = concat(key, parts[i][1]);
              } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
                if (typeof parts[i][2] === "object" && !key) {
                  for (copyKey in parts[i][2]) {
                    if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                      cur[1][copyKey] = parts[i][2][copyKey];
                    }
                  }
                } else {
                  key = concat(key, parts[i][2]);
                }
              } else
                break;
            }
            if (parts[i][0] === ATTR_EQ)
              i++;
            var j = i;
            for (; i < parts.length; i++) {
              if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
                if (!cur[1][key])
                  cur[1][key] = strfn(parts[i][1]);
                else
                  parts[i][1] === "" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
              } else if (parts[i][0] === VAR && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
                if (!cur[1][key])
                  cur[1][key] = strfn(parts[i][2]);
                else
                  parts[i][2] === "" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
              } else {
                if (key.length && !cur[1][key] && i === j && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
                  cur[1][key] = key.toLowerCase();
                }
                if (parts[i][0] === CLOSE) {
                  i--;
                }
                break;
              }
            }
          } else if (s === ATTR_KEY) {
            cur[1][p[1]] = true;
          } else if (s === VAR && p[1] === ATTR_KEY) {
            cur[1][p[2]] = true;
          } else if (s === CLOSE) {
            if (selfClosing(cur[0]) && stack.length) {
              var ix = stack[stack.length - 1][1];
              stack.pop();
              stack[stack.length - 1][0][2][ix] = h(
                cur[0],
                cur[1],
                cur[2].length ? cur[2] : void 0
              );
            }
          } else if (s === VAR && p[1] === TEXT) {
            if (p[2] === void 0 || p[2] === null)
              p[2] = "";
            else if (!p[2])
              p[2] = concat("", p[2]);
            if (Array.isArray(p[2][0])) {
              cur[2].push.apply(cur[2], p[2]);
            } else {
              cur[2].push(p[2]);
            }
          } else if (s === TEXT) {
            cur[2].push(p[1]);
          } else if (s === ATTR_EQ || s === ATTR_BREAK) {
          } else {
            throw new Error("unhandled: " + s);
          }
        }
        if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
          tree[2].shift();
        }
        if (tree[2].length > 2 || tree[2].length === 2 && /\S/.test(tree[2][1])) {
          if (opts.createFragment)
            return opts.createFragment(tree[2]);
          throw new Error(
            "multiple root elements must be wrapped in an enclosing tag"
          );
        }
        if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === "string" && Array.isArray(tree[2][0][2])) {
          tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2]);
        }
        return tree[2][0];
        function parse(str) {
          var res = [];
          if (state === ATTR_VALUE_W)
            state = ATTR;
          for (var i2 = 0; i2 < str.length; i2++) {
            var c2 = str.charAt(i2);
            if (state === TEXT && c2 === "<") {
              if (reg.length)
                res.push([TEXT, reg]);
              reg = "";
              state = OPEN;
            } else if (c2 === ">" && !quot(state) && state !== COMMENT) {
              if (state === OPEN && reg.length) {
                res.push([OPEN, reg]);
              } else if (state === ATTR_KEY) {
                res.push([ATTR_KEY, reg]);
              } else if (state === ATTR_VALUE && reg.length) {
                res.push([ATTR_VALUE, reg]);
              }
              res.push([CLOSE]);
              reg = "";
              state = TEXT;
            } else if (state === COMMENT && /-$/.test(reg) && c2 === "-") {
              if (opts.comments) {
                res.push([ATTR_VALUE, reg.substr(0, reg.length - 1)]);
              }
              reg = "";
              state = TEXT;
            } else if (state === OPEN && /^!--$/.test(reg)) {
              if (opts.comments) {
                res.push([OPEN, reg], [ATTR_KEY, "comment"], [ATTR_EQ]);
              }
              reg = c2;
              state = COMMENT;
            } else if (state === TEXT || state === COMMENT) {
              reg += c2;
            } else if (state === OPEN && c2 === "/" && reg.length) {
            } else if (state === OPEN && /\s/.test(c2)) {
              if (reg.length) {
                res.push([OPEN, reg]);
              }
              reg = "";
              state = ATTR;
            } else if (state === OPEN) {
              reg += c2;
            } else if (state === ATTR && /[^\s"'=/]/.test(c2)) {
              state = ATTR_KEY;
              reg = c2;
            } else if (state === ATTR && /\s/.test(c2)) {
              if (reg.length)
                res.push([ATTR_KEY, reg]);
              res.push([ATTR_BREAK]);
            } else if (state === ATTR_KEY && /\s/.test(c2)) {
              res.push([ATTR_KEY, reg]);
              reg = "";
              state = ATTR_KEY_W;
            } else if (state === ATTR_KEY && c2 === "=") {
              res.push([ATTR_KEY, reg], [ATTR_EQ]);
              reg = "";
              state = ATTR_VALUE_W;
            } else if (state === ATTR_KEY) {
              reg += c2;
            } else if ((state === ATTR_KEY_W || state === ATTR) && c2 === "=") {
              res.push([ATTR_EQ]);
              state = ATTR_VALUE_W;
            } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c2)) {
              res.push([ATTR_BREAK]);
              if (/[\w-]/.test(c2)) {
                reg += c2;
                state = ATTR_KEY;
              } else
                state = ATTR;
            } else if (state === ATTR_VALUE_W && c2 === '"') {
              state = ATTR_VALUE_DQ;
            } else if (state === ATTR_VALUE_W && c2 === "'") {
              state = ATTR_VALUE_SQ;
            } else if (state === ATTR_VALUE_DQ && c2 === '"') {
              res.push([ATTR_VALUE, reg], [ATTR_BREAK]);
              reg = "";
              state = ATTR;
            } else if (state === ATTR_VALUE_SQ && c2 === "'") {
              res.push([ATTR_VALUE, reg], [ATTR_BREAK]);
              reg = "";
              state = ATTR;
            } else if (state === ATTR_VALUE_W && !/\s/.test(c2)) {
              state = ATTR_VALUE;
              i2--;
            } else if (state === ATTR_VALUE && /\s/.test(c2)) {
              res.push([ATTR_VALUE, reg], [ATTR_BREAK]);
              reg = "";
              state = ATTR;
            } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ) {
              reg += c2;
            }
          }
          if (state === TEXT && reg.length) {
            res.push([TEXT, reg]);
            reg = "";
          } else if (state === ATTR_VALUE && reg.length) {
            res.push([ATTR_VALUE, reg]);
            reg = "";
          } else if (state === ATTR_VALUE_DQ && reg.length) {
            res.push([ATTR_VALUE, reg]);
            reg = "";
          } else if (state === ATTR_VALUE_SQ && reg.length) {
            res.push([ATTR_VALUE, reg]);
            reg = "";
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY, reg]);
            reg = "";
          }
          return res;
        }
      };
      function strfn(x) {
        if (typeof x === "function")
          return x;
        else if (typeof x === "string")
          return x;
        else if (x && typeof x === "object")
          return x;
        else if (x === null || x === void 0)
          return x;
        else
          return concat("", x);
      }
    };
    function quot(state) {
      return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ;
    }
    var closeRE = RegExp("^(" + [
      "area",
      "base",
      "basefont",
      "bgsound",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      "!--",
      // SVG TAGS
      "animate",
      "animateTransform",
      "circle",
      "cursor",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "font-face-format",
      "font-face-name",
      "font-face-uri",
      "glyph",
      "glyphRef",
      "hkern",
      "image",
      "line",
      "missing-glyph",
      "mpath",
      "path",
      "polygon",
      "polyline",
      "rect",
      "set",
      "stop",
      "tref",
      "use",
      "view",
      "vkern"
    ].join("|") + ")(?:[.#][a-zA-Z0-9-￿_:-]+)*$");
    function selfClosing(tag) {
      return closeRE.test(tag);
    }
  }
});

// node_modules/choo/node_modules/nanohtml/lib/append-child.js
var require_append_child = __commonJS({
  "node_modules/choo/node_modules/nanohtml/lib/append-child.js"(exports, module) {
    "use strict";
    var trailingNewlineRegex = /\n[\s]+$/;
    var leadingNewlineRegex = /^\n[\s]+/;
    var trailingSpaceRegex = /[\s]+$/;
    var leadingSpaceRegex = /^[\s]+/;
    var multiSpaceRegex = /[\n\s]+/g;
    var TEXT_TAGS = [
      "a",
      "abbr",
      "b",
      "bdi",
      "bdo",
      "br",
      "cite",
      "data",
      "dfn",
      "em",
      "i",
      "kbd",
      "mark",
      "q",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "amp",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "time",
      "u",
      "var",
      "wbr"
    ];
    var VERBATIM_TAGS = [
      "code",
      "pre",
      "textarea"
    ];
    module.exports = function appendChild(el, childs) {
      if (!Array.isArray(childs))
        return;
      var nodeName = el.nodeName.toLowerCase();
      var hadText = false;
      var value, leader;
      for (var i = 0, len = childs.length; i < len; i++) {
        var node = childs[i];
        if (Array.isArray(node)) {
          appendChild(el, node);
          continue;
        }
        if (typeof node === "number" || typeof node === "boolean" || typeof node === "function" || node instanceof Date || node instanceof RegExp) {
          node = node.toString();
        }
        var lastChild = el.childNodes[el.childNodes.length - 1];
        if (typeof node === "string") {
          hadText = true;
          if (lastChild && lastChild.nodeName === "#text") {
            lastChild.nodeValue += node;
          } else {
            node = el.ownerDocument.createTextNode(node);
            el.appendChild(node);
            lastChild = node;
          }
          if (i === len - 1) {
            hadText = false;
            if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
              value = lastChild.nodeValue.replace(leadingNewlineRegex, "").replace(trailingSpaceRegex, "").replace(trailingNewlineRegex, "").replace(multiSpaceRegex, " ");
              if (value === "") {
                el.removeChild(lastChild);
              } else {
                lastChild.nodeValue = value;
              }
            } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
              leader = i === 0 ? "" : " ";
              value = lastChild.nodeValue.replace(leadingNewlineRegex, leader).replace(leadingSpaceRegex, " ").replace(trailingSpaceRegex, "").replace(trailingNewlineRegex, "").replace(multiSpaceRegex, " ");
              lastChild.nodeValue = value;
            }
          }
        } else if (node && node.nodeType) {
          if (hadText) {
            hadText = false;
            if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
              value = lastChild.nodeValue.replace(leadingNewlineRegex, "").replace(trailingNewlineRegex, " ").replace(multiSpaceRegex, " ");
              if (value === "") {
                el.removeChild(lastChild);
              } else {
                lastChild.nodeValue = value;
              }
            } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
              value = lastChild.nodeValue.replace(leadingSpaceRegex, " ").replace(leadingNewlineRegex, "").replace(trailingNewlineRegex, " ").replace(multiSpaceRegex, " ");
              lastChild.nodeValue = value;
            }
          }
          var _nodeName = node.nodeName;
          if (_nodeName)
            nodeName = _nodeName.toLowerCase();
          el.appendChild(node);
        }
      }
    };
  }
});

// node_modules/choo/node_modules/nanohtml/lib/svg-tags.js
var require_svg_tags = __commonJS({
  "node_modules/choo/node_modules/nanohtml/lib/svg-tags.js"(exports, module) {
    "use strict";
    module.exports = [
      "svg",
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "set",
      "stop",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tref",
      "tspan",
      "use",
      "view",
      "vkern"
    ];
  }
});

// node_modules/choo/node_modules/nanohtml/lib/bool-props.js
var require_bool_props = __commonJS({
  "node_modules/choo/node_modules/nanohtml/lib/bool-props.js"(exports, module) {
    "use strict";
    module.exports = [
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defaultchecked",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ];
  }
});

// node_modules/choo/node_modules/nanohtml/lib/direct-props.js
var require_direct_props = __commonJS({
  "node_modules/choo/node_modules/nanohtml/lib/direct-props.js"(exports, module) {
    "use strict";
    module.exports = [
      "indeterminate"
    ];
  }
});

// node_modules/choo/node_modules/nanohtml/lib/dom.js
var require_dom = __commonJS({
  "node_modules/choo/node_modules/nanohtml/lib/dom.js"(exports, module) {
    "use strict";
    var hyperx = require_hyperx();
    var appendChild = require_append_child();
    var SVG_TAGS = require_svg_tags();
    var BOOL_PROPS = require_bool_props();
    var DIRECT_PROPS = require_direct_props();
    var SVGNS = "http://www.w3.org/2000/svg";
    var XLINKNS = "http://www.w3.org/1999/xlink";
    var COMMENT_TAG = "!--";
    module.exports = function(document2) {
      function nanoHtmlCreateElement(tag, props, children) {
        var el;
        if (SVG_TAGS.indexOf(tag) !== -1) {
          props.namespace = SVGNS;
        }
        var ns = false;
        if (props.namespace) {
          ns = props.namespace;
          delete props.namespace;
        }
        var isCustomElement = false;
        if (props.is) {
          isCustomElement = props.is;
          delete props.is;
        }
        if (ns) {
          if (isCustomElement) {
            el = document2.createElementNS(ns, tag, { is: isCustomElement });
          } else {
            el = document2.createElementNS(ns, tag);
          }
        } else if (tag === COMMENT_TAG) {
          return document2.createComment(props.comment);
        } else if (isCustomElement) {
          el = document2.createElement(tag, { is: isCustomElement });
        } else {
          el = document2.createElement(tag);
        }
        for (var p in props) {
          if (props.hasOwnProperty(p)) {
            var key = p.toLowerCase();
            var val = props[p];
            if (key === "classname") {
              key = "class";
              p = "class";
            }
            if (p === "htmlFor") {
              p = "for";
            }
            if (BOOL_PROPS.indexOf(key) !== -1) {
              if (String(val) === "true")
                val = key;
              else if (String(val) === "false")
                continue;
            }
            if (key.slice(0, 2) === "on" || DIRECT_PROPS.indexOf(key) !== -1) {
              el[p] = val;
            } else {
              if (ns) {
                if (p === "xlink:href") {
                  el.setAttributeNS(XLINKNS, p, val);
                } else if (/^xmlns($|:)/i.test(p)) {
                } else {
                  el.setAttributeNS(null, p, val);
                }
              } else {
                el.setAttribute(p, val);
              }
            }
          }
        }
        appendChild(el, children);
        return el;
      }
      function createFragment(nodes) {
        var fragment = document2.createDocumentFragment();
        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i] == null)
            continue;
          if (Array.isArray(nodes[i])) {
            fragment.appendChild(createFragment(nodes[i]));
          } else {
            if (typeof nodes[i] === "string")
              nodes[i] = document2.createTextNode(nodes[i]);
            fragment.appendChild(nodes[i]);
          }
        }
        return fragment;
      }
      var exports2 = hyperx(nanoHtmlCreateElement, {
        comments: true,
        createFragment
      });
      exports2.default = exports2;
      exports2.createComment = nanoHtmlCreateElement;
      return exports2;
    };
  }
});

// node_modules/choo/node_modules/nanohtml/lib/browser.js
var require_browser = __commonJS({
  "node_modules/choo/node_modules/nanohtml/lib/browser.js"(exports, module) {
    module.exports = require_dom()(document);
  }
});

// node_modules/choo/html/index.js
var require_html = __commonJS({
  "node_modules/choo/html/index.js"(exports, module) {
    module.exports = require_browser();
  }
});
export default require_html();
//# sourceMappingURL=choo_html.js.map
