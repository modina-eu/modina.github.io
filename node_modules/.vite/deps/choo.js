import {
  require_browser,
  require_nanoassert,
  require_nanomorph
} from "./chunk-4XJRYKTF.js";
import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// node_modules/choo/node_modules/scroll-to-anchor/index.js
var require_scroll_to_anchor = __commonJS({
  "node_modules/choo/node_modules/scroll-to-anchor/index.js"(exports, module) {
    module.exports = scrollToAnchor;
    function scrollToAnchor(anchor, options) {
      if (anchor) {
        try {
          var el = document.querySelector(anchor);
          if (el)
            el.scrollIntoView(options);
        } catch (e) {
        }
      }
    }
  }
});

// node_modules/choo/node_modules/document-ready/index.js
var require_document_ready = __commonJS({
  "node_modules/choo/node_modules/document-ready/index.js"(exports, module) {
    "use strict";
    module.exports = ready;
    function ready(callback) {
      if (typeof document === "undefined") {
        throw new Error("document-ready only runs in the browser");
      }
      var state = document.readyState;
      if (state === "complete" || state === "interactive") {
        return setTimeout(callback, 0);
      }
      document.addEventListener("DOMContentLoaded", function onLoad() {
        callback();
      });
    }
  }
});

// node_modules/choo/node_modules/wayfarer/trie.js
var require_trie = __commonJS({
  "node_modules/choo/node_modules/wayfarer/trie.js"(exports, module) {
    var assert = require_nanoassert();
    module.exports = Trie;
    function Trie() {
      if (!(this instanceof Trie))
        return new Trie();
      this.trie = { nodes: {} };
    }
    Trie.prototype.create = function(route) {
      assert.equal(typeof route, "string", "route should be a string");
      var routes = route.replace(/^\//, "").split("/");
      function createNode(index, trie) {
        var thisRoute = has(routes, index) && routes[index];
        if (thisRoute === false)
          return trie;
        var node = null;
        if (/^:|^\*/.test(thisRoute)) {
          if (!has(trie.nodes, "$$")) {
            node = { nodes: {} };
            trie.nodes.$$ = node;
          } else {
            node = trie.nodes.$$;
          }
          if (thisRoute[0] === "*") {
            trie.wildcard = true;
          }
          trie.name = thisRoute.replace(/^:|^\*/, "");
        } else if (!has(trie.nodes, thisRoute)) {
          node = { nodes: {} };
          trie.nodes[thisRoute] = node;
        } else {
          node = trie.nodes[thisRoute];
        }
        return createNode(index + 1, node);
      }
      return createNode(0, this.trie);
    };
    Trie.prototype.match = function(route) {
      assert.equal(typeof route, "string", "route should be a string");
      var routes = route.replace(/^\//, "").split("/");
      var params = {};
      function search(index, trie) {
        if (trie === void 0)
          return void 0;
        var thisRoute = routes[index];
        if (thisRoute === void 0)
          return trie;
        if (has(trie.nodes, thisRoute)) {
          return search(index + 1, trie.nodes[thisRoute]);
        } else if (trie.name) {
          try {
            params[trie.name] = decodeURIComponent(thisRoute);
          } catch (e) {
            return search(index, void 0);
          }
          return search(index + 1, trie.nodes.$$);
        } else if (trie.wildcard) {
          try {
            params.wildcard = decodeURIComponent(routes.slice(index).join("/"));
          } catch (e) {
            return search(index, void 0);
          }
          return trie.nodes.$$;
        } else {
          return search(index + 1);
        }
      }
      var node = search(0, this.trie);
      if (!node)
        return void 0;
      node = Object.assign({}, node);
      node.params = params;
      return node;
    };
    Trie.prototype.mount = function(route, trie) {
      assert.equal(typeof route, "string", "route should be a string");
      assert.equal(typeof trie, "object", "trie should be a object");
      var split = route.replace(/^\//, "").split("/");
      var node = null;
      var key = null;
      if (split.length === 1) {
        key = split[0];
        node = this.create(key);
      } else {
        var head = split.join("/");
        key = split[0];
        node = this.create(head);
      }
      Object.assign(node.nodes, trie.nodes);
      if (trie.name)
        node.name = trie.name;
      if (node.nodes[""]) {
        Object.keys(node.nodes[""]).forEach(function(key2) {
          if (key2 === "nodes")
            return;
          node[key2] = node.nodes[""][key2];
        });
        Object.assign(node.nodes, node.nodes[""].nodes);
        delete node.nodes[""].nodes;
      }
    };
    function has(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }
  }
});

// node_modules/choo/node_modules/wayfarer/index.js
var require_wayfarer = __commonJS({
  "node_modules/choo/node_modules/wayfarer/index.js"(exports, module) {
    var assert = require_nanoassert();
    var trie = require_trie();
    module.exports = Wayfarer;
    function Wayfarer(dft) {
      if (!(this instanceof Wayfarer))
        return new Wayfarer(dft);
      var _default = (dft || "").replace(/^\//, "");
      var _trie = trie();
      emit._trie = _trie;
      emit.on = on;
      emit.emit = emit;
      emit.match = match;
      emit._wayfarer = true;
      return emit;
      function on(route, cb) {
        assert.equal(typeof route, "string");
        assert.equal(typeof cb, "function");
        route = route || "/";
        if (cb._wayfarer && cb._trie) {
          _trie.mount(route, cb._trie.trie);
        } else {
          var node = _trie.create(route);
          node.cb = cb;
          node.route = route;
        }
        return emit;
      }
      function emit(route) {
        var matched = match(route);
        var args = new Array(arguments.length);
        args[0] = matched.params;
        for (var i = 1; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return matched.cb.apply(matched.cb, args);
      }
      function match(route) {
        assert.notEqual(route, void 0, "'route' must be defined");
        var matched = _trie.match(route);
        if (matched && matched.cb)
          return new Route(matched);
        var dft2 = _trie.match(_default);
        if (dft2 && dft2.cb)
          return new Route(dft2);
        throw new Error("route '" + route + "' did not match");
      }
      function Route(matched) {
        this.cb = matched.cb;
        this.route = matched.route;
        this.params = matched.params;
      }
    }
  }
});

// node_modules/choo/node_modules/nanorouter/index.js
var require_nanorouter = __commonJS({
  "node_modules/choo/node_modules/nanorouter/index.js"(exports, module) {
    var assert = require_nanoassert();
    var wayfarer = require_wayfarer();
    var isLocalFile = /file:\/\//.test(
      typeof window === "object" && window.location && window.location.origin
    );
    var electron = "^(file://|/)(.*.html?/?)?";
    var protocol = "^(http(s)?(://))?(www.)?";
    var domain = "[a-zA-Z0-9-_.]+(:[0-9]{1,5})?(/{1})?";
    var qs = "[?].*$";
    var stripElectron = new RegExp(electron);
    var prefix = new RegExp(protocol + domain);
    var normalize = new RegExp("#");
    var suffix = new RegExp(qs);
    module.exports = Nanorouter;
    function Nanorouter(opts) {
      if (!(this instanceof Nanorouter))
        return new Nanorouter(opts);
      opts = opts || {};
      this.router = wayfarer(opts.default || "/404");
    }
    Nanorouter.prototype.on = function(routename, listener) {
      assert.equal(typeof routename, "string");
      routename = routename.replace(/^[#/]/, "");
      this.router.on(routename, listener);
    };
    Nanorouter.prototype.emit = function(routename) {
      assert.equal(typeof routename, "string");
      routename = pathname(routename, isLocalFile);
      return this.router.emit(routename);
    };
    Nanorouter.prototype.match = function(routename) {
      assert.equal(typeof routename, "string");
      routename = pathname(routename, isLocalFile);
      return this.router.match(routename);
    };
    function pathname(routename, isElectron) {
      if (isElectron)
        routename = routename.replace(stripElectron, "");
      else
        routename = routename.replace(prefix, "");
      return decodeURI(routename.replace(suffix, "").replace(normalize, "/"));
    }
  }
});

// node_modules/choo/node_modules/nanoquery/browser.js
var require_browser2 = __commonJS({
  "node_modules/choo/node_modules/nanoquery/browser.js"(exports, module) {
    var reg = /([^?=&]+)(=([^&]*))?/g;
    var assert = require_nanoassert();
    module.exports = qs;
    function qs(url) {
      assert.equal(typeof url, "string", "nanoquery: url should be type string");
      var obj = {};
      url.replace(/^.*\?/, "").replace(reg, function(a0, a1, a2, a3) {
        var value = decodeURIComponent(a3);
        var key = decodeURIComponent(a1);
        if (obj.hasOwnProperty(key)) {
          if (Array.isArray(obj[key]))
            obj[key].push(value);
          else
            obj[key] = [obj[key], value];
        } else {
          obj[key] = value;
        }
      });
      return obj;
    }
  }
});

// node_modules/choo/node_modules/nanohref/index.js
var require_nanohref = __commonJS({
  "node_modules/choo/node_modules/nanohref/index.js"(exports, module) {
    var assert = require_nanoassert();
    var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/;
    var protocolLink = /^[\w-_]+:/;
    module.exports = href;
    function href(cb, root) {
      assert.notEqual(typeof window, "undefined", "nanohref: expected window to exist");
      root = root || window.document;
      assert.equal(typeof cb, "function", "nanohref: cb should be type function");
      assert.equal(typeof root, "object", "nanohref: root should be type object");
      window.addEventListener("click", function(e) {
        if (e.button && e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.defaultPrevented)
          return;
        var anchor = function traverse(node) {
          if (!node || node === root)
            return;
          if (node.localName !== "a" || node.href === void 0) {
            return traverse(node.parentNode);
          }
          return node;
        }(e.target);
        if (!anchor)
          return;
        if (window.location.protocol !== anchor.protocol || window.location.hostname !== anchor.hostname || window.location.port !== anchor.port || anchor.hasAttribute("data-nanohref-ignore") || anchor.hasAttribute("download") || anchor.getAttribute("target") === "_blank" && safeExternalLink.test(anchor.getAttribute("rel")) || protocolLink.test(anchor.getAttribute("href")))
          return;
        e.preventDefault();
        cb(anchor);
      });
    }
  }
});

// node_modules/choo/node_modules/nanoraf/index.js
var require_nanoraf = __commonJS({
  "node_modules/choo/node_modules/nanoraf/index.js"(exports, module) {
    "use strict";
    var assert = require_nanoassert();
    module.exports = nanoraf;
    function nanoraf(render, raf) {
      assert.equal(typeof render, "function", "nanoraf: render should be a function");
      assert.ok(typeof raf === "function" || typeof raf === "undefined", "nanoraf: raf should be a function or undefined");
      if (!raf)
        raf = window.requestAnimationFrame;
      var redrawScheduled = false;
      var args = null;
      return function frame() {
        if (args === null && !redrawScheduled) {
          redrawScheduled = true;
          raf(function redraw() {
            redrawScheduled = false;
            var length = args.length;
            var _args = new Array(length);
            for (var i = 0; i < length; i++)
              _args[i] = args[i];
            render.apply(render, _args);
            args = null;
          });
        }
        args = arguments;
      };
    }
  }
});

// node_modules/choo/node_modules/remove-array-items/index.js
var require_remove_array_items = __commonJS({
  "node_modules/choo/node_modules/remove-array-items/index.js"(exports, module) {
    "use strict";
    module.exports = function removeItems(arr, startIdx, removeCount) {
      var i, length = arr.length;
      if (startIdx >= length || removeCount === 0) {
        return;
      }
      removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
      var len = length - removeCount;
      for (i = startIdx; i < len; ++i) {
        arr[i] = arr[i + removeCount];
      }
      arr.length = len;
    };
  }
});

// node_modules/choo/node_modules/nanobus/index.js
var require_nanobus = __commonJS({
  "node_modules/choo/node_modules/nanobus/index.js"(exports, module) {
    var splice = require_remove_array_items();
    var nanotiming = require_browser();
    var assert = require_nanoassert();
    module.exports = Nanobus;
    function Nanobus(name) {
      if (!(this instanceof Nanobus))
        return new Nanobus(name);
      this._name = name || "nanobus";
      this._starListeners = [];
      this._listeners = {};
    }
    Nanobus.prototype.emit = function(eventName) {
      assert.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.emit: eventName should be type string or symbol");
      var data = [];
      for (var i = 1, len = arguments.length; i < len; i++) {
        data.push(arguments[i]);
      }
      var emitTiming = nanotiming(this._name + "('" + eventName.toString() + "')");
      var listeners = this._listeners[eventName];
      if (listeners && listeners.length > 0) {
        this._emit(this._listeners[eventName], data);
      }
      if (this._starListeners.length > 0) {
        this._emit(this._starListeners, eventName, data, emitTiming.uuid);
      }
      emitTiming();
      return this;
    };
    Nanobus.prototype.on = Nanobus.prototype.addListener = function(eventName, listener) {
      assert.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.on: eventName should be type string or symbol");
      assert.equal(typeof listener, "function", "nanobus.on: listener should be type function");
      if (eventName === "*") {
        this._starListeners.push(listener);
      } else {
        if (!this._listeners[eventName])
          this._listeners[eventName] = [];
        this._listeners[eventName].push(listener);
      }
      return this;
    };
    Nanobus.prototype.prependListener = function(eventName, listener) {
      assert.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.prependListener: eventName should be type string or symbol");
      assert.equal(typeof listener, "function", "nanobus.prependListener: listener should be type function");
      if (eventName === "*") {
        this._starListeners.unshift(listener);
      } else {
        if (!this._listeners[eventName])
          this._listeners[eventName] = [];
        this._listeners[eventName].unshift(listener);
      }
      return this;
    };
    Nanobus.prototype.once = function(eventName, listener) {
      assert.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.once: eventName should be type string or symbol");
      assert.equal(typeof listener, "function", "nanobus.once: listener should be type function");
      var self = this;
      this.on(eventName, once);
      function once() {
        listener.apply(self, arguments);
        self.removeListener(eventName, once);
      }
      return this;
    };
    Nanobus.prototype.prependOnceListener = function(eventName, listener) {
      assert.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.prependOnceListener: eventName should be type string or symbol");
      assert.equal(typeof listener, "function", "nanobus.prependOnceListener: listener should be type function");
      var self = this;
      this.prependListener(eventName, once);
      function once() {
        listener.apply(self, arguments);
        self.removeListener(eventName, once);
      }
      return this;
    };
    Nanobus.prototype.removeListener = function(eventName, listener) {
      assert.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.removeListener: eventName should be type string or symbol");
      assert.equal(typeof listener, "function", "nanobus.removeListener: listener should be type function");
      if (eventName === "*") {
        this._starListeners = this._starListeners.slice();
        return remove(this._starListeners, listener);
      } else {
        if (typeof this._listeners[eventName] !== "undefined") {
          this._listeners[eventName] = this._listeners[eventName].slice();
        }
        return remove(this._listeners[eventName], listener);
      }
      function remove(arr, listener2) {
        if (!arr)
          return;
        var index = arr.indexOf(listener2);
        if (index !== -1) {
          splice(arr, index, 1);
          return true;
        }
      }
    };
    Nanobus.prototype.removeAllListeners = function(eventName) {
      if (eventName) {
        if (eventName === "*") {
          this._starListeners = [];
        } else {
          this._listeners[eventName] = [];
        }
      } else {
        this._starListeners = [];
        this._listeners = {};
      }
      return this;
    };
    Nanobus.prototype.listeners = function(eventName) {
      var listeners = eventName !== "*" ? this._listeners[eventName] : this._starListeners;
      var ret = [];
      if (listeners) {
        var ilength = listeners.length;
        for (var i = 0; i < ilength; i++)
          ret.push(listeners[i]);
      }
      return ret;
    };
    Nanobus.prototype._emit = function(arr, eventName, data, uuid) {
      if (typeof arr === "undefined")
        return;
      if (arr.length === 0)
        return;
      if (data === void 0) {
        data = eventName;
        eventName = null;
      }
      if (eventName) {
        if (uuid !== void 0) {
          data = [eventName].concat(data, uuid);
        } else {
          data = [eventName].concat(data);
        }
      }
      var length = arr.length;
      for (var i = 0; i < length; i++) {
        var listener = arr[i];
        listener.apply(listener, data);
      }
    };
  }
});

// node_modules/choo/node_modules/nanolru/index.js
var require_nanolru = __commonJS({
  "node_modules/choo/node_modules/nanolru/index.js"(exports, module) {
    module.exports = LRU;
    function LRU(opts) {
      if (!(this instanceof LRU))
        return new LRU(opts);
      if (typeof opts === "number")
        opts = { max: opts };
      if (!opts)
        opts = {};
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
      this.max = opts.max || 1e3;
      this.maxAge = opts.maxAge || 0;
    }
    Object.defineProperty(LRU.prototype, "keys", {
      get: function() {
        return Object.keys(this.cache);
      }
    });
    LRU.prototype.clear = function() {
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
    };
    LRU.prototype.remove = function(key) {
      if (typeof key !== "string")
        key = "" + key;
      if (!this.cache.hasOwnProperty(key))
        return;
      var element = this.cache[key];
      delete this.cache[key];
      this._unlink(key, element.prev, element.next);
      return element.value;
    };
    LRU.prototype._unlink = function(key, prev, next) {
      this.length--;
      if (this.length === 0) {
        this.head = this.tail = null;
      } else {
        if (this.head === key) {
          this.head = prev;
          this.cache[this.head].next = null;
        } else if (this.tail === key) {
          this.tail = next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[prev].next = next;
          this.cache[next].prev = prev;
        }
      }
    };
    LRU.prototype.peek = function(key) {
      if (!this.cache.hasOwnProperty(key))
        return;
      var element = this.cache[key];
      if (!this._checkAge(key, element))
        return;
      return element.value;
    };
    LRU.prototype.set = function(key, value) {
      if (typeof key !== "string")
        key = "" + key;
      var element;
      if (this.cache.hasOwnProperty(key)) {
        element = this.cache[key];
        element.value = value;
        if (this.maxAge)
          element.modified = Date.now();
        if (key === this.head)
          return value;
        this._unlink(key, element.prev, element.next);
      } else {
        element = { value, modified: 0, next: null, prev: null };
        if (this.maxAge)
          element.modified = Date.now();
        this.cache[key] = element;
        if (this.length === this.max)
          this.evict();
      }
      this.length++;
      element.next = null;
      element.prev = this.head;
      if (this.head)
        this.cache[this.head].next = key;
      this.head = key;
      if (!this.tail)
        this.tail = key;
      return value;
    };
    LRU.prototype._checkAge = function(key, element) {
      if (this.maxAge && Date.now() - element.modified > this.maxAge) {
        this.remove(key);
        return false;
      }
      return true;
    };
    LRU.prototype.get = function(key) {
      if (typeof key !== "string")
        key = "" + key;
      if (!this.cache.hasOwnProperty(key))
        return;
      var element = this.cache[key];
      if (!this._checkAge(key, element))
        return;
      if (this.head !== key) {
        if (key === this.tail) {
          this.tail = element.next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[element.prev].next = element.next;
        }
        this.cache[element.next].prev = element.prev;
        this.cache[this.head].next = key;
        element.prev = this.head;
        element.next = null;
        this.head = key;
      }
      return element.value;
    };
    LRU.prototype.evict = function() {
      if (!this.tail)
        return;
      this.remove(this.tail);
    };
  }
});

// node_modules/choo/component/cache.js
var require_cache = __commonJS({
  "node_modules/choo/component/cache.js"(exports, module) {
    var assert = require_nanoassert();
    var LRU = require_nanolru();
    module.exports = ChooComponentCache;
    function ChooComponentCache(state, emit, lru) {
      assert.ok(this instanceof ChooComponentCache, "ChooComponentCache should be created with `new`");
      assert.equal(typeof state, "object", "ChooComponentCache: state should be type object");
      assert.equal(typeof emit, "function", "ChooComponentCache: emit should be type function");
      if (typeof lru === "number")
        this.cache = new LRU(lru);
      else
        this.cache = lru || new LRU(100);
      this.state = state;
      this.emit = emit;
    }
    ChooComponentCache.prototype.render = function(Component, id) {
      assert.equal(typeof Component, "function", "ChooComponentCache.render: Component should be type function");
      assert.ok(typeof id === "string" || typeof id === "number", "ChooComponentCache.render: id should be type string or type number");
      var el = this.cache.get(id);
      if (!el) {
        var args = [];
        for (var i = 2, len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args.unshift(Component, id, this.state, this.emit);
        el = newCall.apply(newCall, args);
        this.cache.set(id, el);
      }
      return el;
    };
    function newCall(Cls) {
      return new (Cls.bind.apply(Cls, arguments))();
    }
  }
});

// node_modules/choo/index.js
var require_choo = __commonJS({
  "node_modules/choo/index.js"(exports, module) {
    var scrollToAnchor = require_scroll_to_anchor();
    var documentReady = require_document_ready();
    var nanotiming = require_browser();
    var nanorouter = require_nanorouter();
    var nanomorph = require_nanomorph();
    var nanoquery = require_browser2();
    var nanohref = require_nanohref();
    var nanoraf = require_nanoraf();
    var nanobus = require_nanobus();
    var assert = require_nanoassert();
    var Cache = require_cache();
    module.exports = Choo;
    var HISTORY_OBJECT = {};
    function Choo(opts) {
      var timing = nanotiming("choo.constructor");
      if (!(this instanceof Choo))
        return new Choo(opts);
      opts = opts || {};
      assert.equal(typeof opts, "object", "choo: opts should be type object");
      var self = this;
      this._events = {
        DOMCONTENTLOADED: "DOMContentLoaded",
        DOMTITLECHANGE: "DOMTitleChange",
        REPLACESTATE: "replaceState",
        PUSHSTATE: "pushState",
        NAVIGATE: "navigate",
        POPSTATE: "popState",
        RENDER: "render"
      };
      this._historyEnabled = opts.history === void 0 ? true : opts.history;
      this._hrefEnabled = opts.href === void 0 ? true : opts.href;
      this._hashEnabled = opts.hash === void 0 ? false : opts.hash;
      this._hasWindow = typeof window !== "undefined";
      this._cache = opts.cache;
      this._loaded = false;
      this._stores = [ondomtitlechange];
      this._tree = null;
      var _state = {
        events: this._events,
        components: {}
      };
      if (this._hasWindow) {
        this.state = window.initialState ? Object.assign({}, window.initialState, _state) : _state;
        delete window.initialState;
      } else {
        this.state = _state;
      }
      this.router = nanorouter({ curry: true });
      this.emitter = nanobus("choo.emit");
      this.emit = this.emitter.emit.bind(this.emitter);
      if (this._hasWindow)
        this.state.title = document.title;
      function ondomtitlechange(state) {
        self.emitter.prependListener(self._events.DOMTITLECHANGE, function(title) {
          assert.equal(typeof title, "string", "events.DOMTitleChange: title should be type string");
          state.title = title;
          if (self._hasWindow)
            document.title = title;
        });
      }
      timing();
    }
    Choo.prototype.route = function(route, handler) {
      var routeTiming = nanotiming("choo.route('" + route + "')");
      assert.equal(typeof route, "string", "choo.route: route should be type string");
      assert.equal(typeof handler, "function", "choo.handler: route should be type function");
      this.router.on(route, handler);
      routeTiming();
    };
    Choo.prototype.use = function(cb) {
      assert.equal(typeof cb, "function", "choo.use: cb should be type function");
      var self = this;
      this._stores.push(function(state) {
        var msg = "choo.use";
        msg = cb.storeName ? msg + "(" + cb.storeName + ")" : msg;
        var endTiming = nanotiming(msg);
        cb(state, self.emitter, self);
        endTiming();
      });
    };
    Choo.prototype.start = function() {
      assert.equal(typeof window, "object", "choo.start: window was not found. .start() must be called in a browser, use .toString() if running in Node");
      var startTiming = nanotiming("choo.start");
      var self = this;
      if (this._historyEnabled) {
        this.emitter.prependListener(this._events.NAVIGATE, function() {
          self._matchRoute(self.state);
          if (self._loaded) {
            self.emitter.emit(self._events.RENDER);
            setTimeout(scrollToAnchor.bind(null, window.location.hash), 0);
          }
        });
        this.emitter.prependListener(this._events.POPSTATE, function() {
          self.emitter.emit(self._events.NAVIGATE);
        });
        this.emitter.prependListener(this._events.PUSHSTATE, function(href) {
          assert.equal(typeof href, "string", "events.pushState: href should be type string");
          window.history.pushState(HISTORY_OBJECT, null, href);
          self.emitter.emit(self._events.NAVIGATE);
        });
        this.emitter.prependListener(this._events.REPLACESTATE, function(href) {
          assert.equal(typeof href, "string", "events.replaceState: href should be type string");
          window.history.replaceState(HISTORY_OBJECT, null, href);
          self.emitter.emit(self._events.NAVIGATE);
        });
        window.onpopstate = function() {
          self.emitter.emit(self._events.POPSTATE);
        };
        if (self._hrefEnabled) {
          nanohref(function(location) {
            var href = location.href;
            var hash = location.hash;
            if (href === window.location.href) {
              if (!self._hashEnabled && hash)
                scrollToAnchor(hash);
              return;
            }
            self.emitter.emit(self._events.PUSHSTATE, href);
          });
        }
      }
      this._setCache(this.state);
      this._matchRoute(this.state);
      this._stores.forEach(function(initStore) {
        initStore(self.state);
      });
      this._tree = this._prerender(this.state);
      assert.ok(this._tree, "choo.start: no valid DOM node returned for location " + this.state.href);
      this.emitter.prependListener(self._events.RENDER, nanoraf(function() {
        var renderTiming = nanotiming("choo.render");
        var newTree = self._prerender(self.state);
        assert.ok(newTree, "choo.render: no valid DOM node returned for location " + self.state.href);
        assert.equal(self._tree.nodeName, newTree.nodeName, "choo.render: The target node <" + self._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
        var morphTiming = nanotiming("choo.morph");
        nanomorph(self._tree, newTree);
        morphTiming();
        renderTiming();
      }));
      documentReady(function() {
        self.emitter.emit(self._events.DOMCONTENTLOADED);
        self._loaded = true;
      });
      startTiming();
      return this._tree;
    };
    Choo.prototype.mount = function mount(selector) {
      var mountTiming = nanotiming("choo.mount('" + selector + "')");
      if (typeof window !== "object") {
        assert.ok(typeof selector === "string", "choo.mount: selector should be type String");
        this.selector = selector;
        mountTiming();
        return this;
      }
      assert.ok(typeof selector === "string" || typeof selector === "object", "choo.mount: selector should be type String or HTMLElement");
      var self = this;
      documentReady(function() {
        var renderTiming = nanotiming("choo.render");
        var newTree = self.start();
        if (typeof selector === "string") {
          self._tree = document.querySelector(selector);
        } else {
          self._tree = selector;
        }
        assert.ok(self._tree, "choo.mount: could not query selector: " + selector);
        assert.equal(self._tree.nodeName, newTree.nodeName, "choo.mount: The target node <" + self._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
        var morphTiming = nanotiming("choo.morph");
        nanomorph(self._tree, newTree);
        morphTiming();
        renderTiming();
      });
      mountTiming();
    };
    Choo.prototype.toString = function(location, state) {
      state = state || {};
      state.components = state.components || {};
      state.events = Object.assign({}, state.events, this._events);
      assert.notEqual(typeof window, "object", "choo.mount: window was found. .toString() must be called in Node, use .start() or .mount() if running in the browser");
      assert.equal(typeof location, "string", "choo.toString: location should be type string");
      assert.equal(typeof state, "object", "choo.toString: state should be type object");
      this._setCache(state);
      this._matchRoute(state, location);
      this.emitter.removeAllListeners();
      this._stores.forEach(function(initStore) {
        initStore(state);
      });
      var html = this._prerender(state);
      assert.ok(html, "choo.toString: no valid value returned for the route " + location);
      assert(!Array.isArray(html), "choo.toString: return value was an array for the route " + location);
      return typeof html.outerHTML === "string" ? html.outerHTML : html.toString();
    };
    Choo.prototype._matchRoute = function(state, locationOverride) {
      var location, queryString;
      if (locationOverride) {
        location = locationOverride.replace(/\?.+$/, "").replace(/\/$/, "");
        if (!this._hashEnabled)
          location = location.replace(/#.+$/, "");
        queryString = locationOverride;
      } else {
        location = window.location.pathname.replace(/\/$/, "");
        if (this._hashEnabled)
          location += window.location.hash.replace(/^#/, "/");
        queryString = window.location.search;
      }
      var matched = this.router.match(location);
      this._handler = matched.cb;
      state.href = location;
      state.query = nanoquery(queryString);
      state.route = matched.route;
      state.params = matched.params;
    };
    Choo.prototype._prerender = function(state) {
      var routeTiming = nanotiming("choo.prerender('" + state.route + "')");
      var res = this._handler(state, this.emit);
      routeTiming();
      return res;
    };
    Choo.prototype._setCache = function(state) {
      var cache = new Cache(state, this.emitter.emit.bind(this.emitter), this._cache);
      state.cache = renderComponent;
      function renderComponent(Component, id) {
        assert.equal(typeof Component, "function", "choo.state.cache: Component should be type function");
        var args = [];
        for (var i = 0, len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return cache.render.apply(cache, args);
      }
      renderComponent.toJSON = function() {
        return null;
      };
    };
  }
});
export default require_choo();
//# sourceMappingURL=choo.js.map
